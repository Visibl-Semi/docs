---
title: Examples
description: Practical examples of using Visibl for silicon engineering
---

Examples demonstrating Visibl's capabilities for complex RTL design and verification challenges.

## Clock Domain Crossing

Design a safe CDC circuit—demonstrates understanding of timing and metastability:

```bash
visibl
```

```
> I need a multi-bit clock domain crossing circuit for a 32-bit data bus
> crossing from a 200MHz domain to a 100MHz domain. Requirements:
> - Gray code encoding for pointer comparison
> - Two-stage synchronizer for control signals
> - Proper constraints for static timing analysis
> - Formal verification properties to prove no metastability issues

> Now add FIFO buffering with almost-full/empty thresholds
> Set almost-full at 75% to provide back-pressure

> Generate SVA properties to verify:
> - No data loss during clock domain crossing
> - Proper synchronization of all control signals
> - Gray code pointer integrity
```

**Why this matters**: CDC failures are non-deterministic and escape functional simulation. Requires understanding of metastability windows, gray code mathematics, and formal verification.

## AXI4 Protocol Implementation

Generate a complete AXI4-Lite slave interface—shows protocol expertise:

```bash
visibl
```

```
> Create an AXI4-Lite slave interface for a register bank
> 32-bit data width, 16 registers starting at address 0x1000
> Registers 0-7 are read-write, 8-15 are read-only status registers

> Add proper BVALID/BREADY handshaking with OKAY/SLVERR responses
> Return SLVERR for any address outside the register range or misaligned access

> Generate a UVM monitor to verify all AXI4-Lite protocol rules:
> - VALID/READY handshaking requirements
> - Write response ordering
> - Address alignment
> - No deadlocks
```

**Why this matters**: AXI protocol compliance requires precise handshaking semantics. Subtle violations cause system-level integration failures that are expensive to debug post-tapeout.

## Complex Timing Closure

Analyze and resolve a real-world timing violation:

```bash
visibl
```

```
> I have setup timing violations in my cache controller synthesized at 500MHz on 7nm:
> 
> Critical paths (from PrimeTime):
> 1. tag_compare[3] -> way_select[1] -> data_mux -> cpu_data_out (-0.8ns slack)
> 2. victim_buffer/lru_update -> victim_buffer/evict_addr (-0.4ns slack)
> 
> The tag comparator uses 4-way set associative with parallel comparison.
> The LRU uses pseudo-LRU binary tree for victim selection.
> 
> Suggest RTL modifications to fix timing without changing the cache architecture.
> Consider: pipeline stage insertion, logic restructuring, and critical path analysis.

> Now update the cache testbench to verify the pipelined implementation
> Make sure we test back-to-back hits, miss-hit-miss patterns, and hazards

> Generate timing constraints (SDC) for the modified design
> Include: cache clock definition, input/output delays, multicycle paths for LRU update
```

**Why this matters**: Timing closure at advanced nodes requires RTL restructuring without functional changes. Demonstrates critical path analysis, pipeline insertion trade-offs, and constraint methodology.

## Cache Coherency Protocol

Design a coherency protocol with state machine verification:

```bash
visibl
```

```
> I'm implementing a MESI cache coherency protocol for a 4-core system
> Help me design the cache line state machine for the L1 cache

> Each cache needs to handle: local CPU requests, snoop requests from other caches,
> and responses from the L2 cache. What are the state transitions and when do we
> need to broadcast invalidates?

> Now handle the race condition: what happens when a local write request and
> a remote snoop invalidate arrive in the same cycle? How do we arbitrate?

> Generate SystemVerilog assertions to verify MESI protocol invariants:
> - Only one cache can be in Modified state for any cache line
> - Shared state is consistent across all caches
> - State transitions are legal
> - No deadlocks in the coherency fabric
```

**Why this matters**: MESI coherency involves distributed state machines with race conditions. Data corruption bugs appear only under specific timing scenarios and are nearly impossible to debug in simulation.

## Doc Agent

Generate comprehensive documentation for RTL modules. See the [Doc Agent](/cli/doc-gen) section for complete details.

```bash
visibl
/docs uart_core
```

Or use headless mode:
```bash
visibl docs uart_core
```

## Multi-File Refactoring

Complex refactoring across your entire design:

```bash
visibl
```

```
> I need to add a new pipeline stage to my processor core between
> the decode and execute stages. This affects:
> - core/decode.sv
> - core/execute.sv  
> - core/hazard_unit.sv
> - core/forwarding_unit.sv
> - testbench/cpu_tb.sv
> 
> Walk me through the changes needed and update all files to maintain
> correct hazard detection and data forwarding

> Now we need to update the testbench to verify the new pipeline stage
> Add test cases for data hazards with the additional pipeline stage
```

**Why this matters**: Architectural changes require coordinated modifications across RTL, verification, and constraints. Maintaining correctness during refactoring is critical for tape-out schedules.

## Next Steps

<CardGroup cols={2}>
  <Card title="Doc Agent" icon="file-text" href="/cli/doc-gen">
    Generate comprehensive RTL documentation
  </Card>
  
  <Card title="Chat" icon="messages" href="/cli/chat">
    Learn about the interactive interface
  </Card>
  
  <Card title="CLI Overview" icon="terminal" href="/cli/overview">
    Explore all capabilities
  </Card>
  
  <Card title="Installation" icon="download" href="/cli/installation">
    Install and configure the CLI
  </Card>
</CardGroup>
